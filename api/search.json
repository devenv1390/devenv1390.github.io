[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-03-09T04:34:08.493Z","categories_index":"搭建环境","tags_index":"配置方式","author_index":"Kaiyuan Qin"},{"id":"2fea1ef2357ec7f028dab0f4a3487a7c","title":"Kotlin协程","content":"Kotlin 协程Kotlin程序至少会有一个线程，而这个线程也就是我们常说的主线程。程序启动后由Java虚拟机创建主线程，程序结束后由java虚拟机销毁主线程。而我们开发人员创建的各种线程都是子线程。主线程负责管理子线程的启动，挂起，停止等操作。而主线程，在我们应用开发中还有一个名称：UI线程。\n线程下面通过示例了解一下线程 Thread的作用吧：\nfun main(args: Array&lt;String>) &#123;\n    Thread(\n        Runnable &#123;\n            Thread.sleep(1000L)\n            println(\"Hello World\")\n        &#125;\n    ).start()\n    println(\"delay 1s\")\n&#125;\n\n输出结果是：\ndelay 1s \nHello World\n\n可以看到，我们通过调用线程中的 sleep()方法将整个子线程延时1秒再执行。但主线程是直接执行并输出了 delay 1s，通过这个例子就能很直观地看出子线程与主线程的运行状态。\n协程一般来说，在进行开发的时候，碰到一些需要耗费时间的操作，例如网络IO、文件IO等任务时，这些任务会阻塞线程直到整个任务完成。而线程的阻塞问题除了可以通过开启新的线程来解决问题，还可以通过协程来解决。\n基础概念协程是一个可暂停计算的实例。它在概念上类似于一个线程，因为它需要一个代码块来运行，与其他代码同时工作。然而，一个循环程序并不会被绑定到任何特定的线程。它可以在一个线程中暂停执行，在另一个线程中继续执行。协程可以被认为是轻量级的线程，但有一些重要的区别，使其在实际的使用中与线程非常不同。\n协程的使用下面我们通过一段代码来感受一下协程的调用：\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking &#123; \n    launch &#123; \n        delay(1000L) \n        println(\"World!\") \n    &#125;\n    println(\"Hello\")\n&#125;\n\n运行的结果：\nHello\nWorld!\n\n让我们来剖析一下这段代码的作用：\nlaunch&#123;&#125;是一个协程构建器。它会启动一个新的协程，让该程序继续独立工作，而不影响其他部分的程序。这就是为什么Hello被首先打印出来。delay()是一个特殊的暂停函数。它可以在一个特定的时间内暂停该协程。暂停一个协程不会阻塞主线程，但允许其他协程运行并使用底层线程来运行代码。runBlocking也是一个建立协程的工具，它连接了普通 fun main()的非协程部分和 runBlocking &#123; ... &#125;花括号内的嵌套部分。CoroutineScope提示就在 runBlocking开头的花括号之后。如果你在这段代码中删除或忘记了 runBlocking，你会在调用 launch 时得到一个错误，因为 launch只在 CoroutineScope上声明。\nUnresolved reference: launch\n\nrunBlocking的名字意味着运行它的线程（在本例中是主线程）在调用期间会被阻塞，直到 runBlocking &#123; ... &#125;内的所有程序都完成执行。你会经常看到 runBlocking在应用程序的最顶层使用，而在实际代码中很少使用，因为线程是昂贵的资源，阻塞它们是低效的，而且往往是不受欢迎的。\n结构化的并发性协程遵循结构化并发的原则，这意味着新的协程只能在一个特定的 CoroutineScope中启动，这个 CoroutineScope限定了协程的生命周期。上面的例子显示，runBlocking建立了相应的范围，这就是为什么前面的例子会等待直到 World！在一秒钟的延迟后被打印出来才退出进程。在实际应用中，我们将会启动很多的协程。结构化的并发性确保它们不会丢失，也不会泄漏。一个外层作用域在其所有子层的协程完成之前不能完成。结构化的并发性还可以确保代码中的任何错误都被正确地报告，并且永远不会丢失。\n提取函数重构让我们把 launch&#123; ... &#125;中的代码块提取到一个单独的函数中。当对这段代码进行 “提取函数 “重构时，你会得到一个带有 suspend modifier的新函数，这是一个挂起函数。挂起函数可以像普通函数一样用在协程内部，但它们的特点是，它们可以反过来使用其他挂起的函数（比如本例中的 delay）来挂起协程的执行。\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking &#123; \n    launch &#123; doWorld() &#125;\n    println(\"Hello\")\n&#125;\n\nsuspend fun doWorld() &#123;\n    delay(1000L)\n    println(\"World!\")\n&#125;\n\n作用域构建器除了不同的构建器所提供的协程作用域之外，还可以使用 coroutineScope构建器来声明你自己的作用域。它创建了一个协程作用域，在所有启动的子程序完成之前都不会完成。\nrunBlocking和 coroutineScope构建器看起来很相似，因为它们都在等待其主程序和所有子程序完成。主要的区别是，runBlocking方法阻断了当前线程的等待，而 coroutineScope只是暂停，释放底层的线程用于其他用途。正是因为这个区别，所以我们可以将 runBlocking看做是一个普通的函数，而 coroutineScope是一个暂停的函数。我们可以从任何暂停函数中使用 coroutineScope。例如，可以将 Hello和 World的并发打印转移到一个暂停的函数 doWorld()中。\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking &#123;\n    doWorld()\n&#125;\n\nsuspend fun doWorld() = coroutineScope &#123;  \n    launch &#123;\n        delay(1000L)\n        println(\"World!\")\n    &#125;\n    println(\"Hello\")\n&#125;\n\n作用域构建器和其并发性coroutineScope构建器可以在任何暂停函数中使用，以执行多个并发的操作。让我们在一个 doWorld()挂起的函数中启动两个并发的 coroutine。\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking &#123;\n    doWorld()\n    println(\"Done\")\n&#125;\n\nsuspend fun doWorld() = coroutineScope &#123;\n    launch &#123;\n        delay(2000L)\n        println(\"World 2\")\n    &#125;\n    launch &#123;\n        delay(1000L)\n        println(\"World 1\")\n    &#125;\n    println(\"Hello\")\n&#125;\n\n这两段代码在 launch&#123; ... &#125;同时执行，从开始的一秒钟后，先打印 World 1，从开始的两秒钟后，接着打印 World 2。doWorld()中的一个 coroutineScope只有在这两段代码完成后才会完成，所以 doWorld()执行完所有的协程后返回，而 Done字符串在这之后才被打印出来：\nHello\nWorld 1\nWorld 2\nDone\n\n协程中的显式Job一个 launch coroutine builder 会返回一个 Job 对象，该对象是启动 coroutine的方法，可用于显式地等待其完成。例如，你可以等待协程的完成，然后打印 Done字符串。\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking &#123;\n    val job = launch &#123;\n        delay(1000L)\n        println(\"World!\")\n    &#125;\n    println(\"Hello\")\n    job.join() \n    println(\"Done\") \n&#125;\n\n代码结果如下：\nHello\nWorld!\nDone\n\n协程很轻量Coroutines比 JVM线程的资源密集度低。使用线程时容易耗尽 JVM可用内存的代码，而使用协程则不会触及资源限制。例如，下面的代码启动了100000个不同的 coroutines，每个 coroutines等待5秒，然后打印一个句号 （&#39;.&#39;），而消耗的内存非常少。\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking &#123;\n    repeat(100_000) &#123; // 启动大量的协程\n        launch &#123;\n            delay(5000L)\n            print(\".\")\n        &#125;\n    &#125;\n&#125;\n\n如果你用线程编写同样的程序（去掉 runBlocking，用线程代替启动，用 Thread.sleep代替延迟），它很可能会消耗过多的内存，并抛出一个内存不足的错误。\n","slug":"Kotlin协程","date":"2022-10-26T02:36:06.000Z","categories_index":"Code","tags_index":"Kotlin","author_index":"Kaiyuan Qin"},{"id":"1c3acb343b4f9d341101747d7fd21b89","title":"快速入门Kotlin","content":"快速入门 Kotlin在开始这一切的一切之前，我想你应该已经了解了Kotlin 的基本语法，如果你还不是很了解，可以查看Kotlin 的中文文档来浅浅了解一下。\n变量Kotlin 中的变量分为两种类型，分别为可变变量和不可变变量。\n可变变量使用关键字var来修饰，可以进行多次修改（词源 variable，指可变的）。\n不可变变量使用关键字val来修饰，在初始化后就不可再对其进行修改，相当于一个常量（词源 value，指一个值）。\n那么我们该如何在 Kotlin 中声明变量和给变量赋值呢？方法其实和其他的语言差不多，就是关键字加变量名然后赋值。\n这里先展示几种定义变量的方法，也需要遵守Kotlin 的基本语法，需要记住的是，常量与变量都可以没有初始化值,但是在引用前必须初始化。\nval crazyThu = 50\nval crazyThu : Int = 50\n//不可变变量\n/*-------分割线-------*/\nvar crazyThu= 50\nvar crazyThu : Int = 50\n\nval crazyThu\ncrazyThu = 50\n//可变变量\n\n这时候有学习过其他语言的聪明同学可能就会问：“这不是只有var和val两种变量类型吗，如果不声明变量所存储的数据类型，编译器怎么判断变量储存的数据类型是什么呢？”。\n这就不得不提到 Kotlin 的特色，类型推导机制。下面举个例子来说明一下。\nfun main()\n&#123;\n  val crazyThu = 50\n  println(crazyThu)\n&#125;\n\n可以看到，很神奇啊，我们使用了val关键字定义了变量crazyThu，然后给它赋值 50，这时候你肯定知道，50 是一个Int类型也就是整型的数值，这个推导机制也一样，他这时候根据你给变量赋值的类型，来推断出这个crazyThu变量是一个整型变量。假如你这样写val crazyThu = &quot;vivo50&quot;，给crazyThu赋上一个字符串值，推导机制就会认为crazyThu是一个字符串类型的变量，而当你明确告诉它val crazyThu : Int = 50时，推导机制也就不会去进行推断了。但是需要注意的是，这样定义的变量不可以进行延时赋值操作的。\n下面列举了一些在声明变量和给变量赋值时可能会出现的问题：\n1.当不赋初始值时，不对变量进行具体类型的约束\nfun main()\n&#123;\n  var crazyThu\n  /*当不赋初始值时，不对变量进行具体类型的约束，会造成错误*/\n&#125;\n\n\n2.在同个函数内进行重复定义\nfun main()\n&#123;\n  var crazyThu : Int\n  var crazyThu : String\n  /*不能在同个函数内进行重复定义*/\n&#125;\n\n\nAnd so on…\n\n变量的数据类型数值型\n\n\n类型名\n描述\n占用空间\n存储值范围\n示例\n\n\n\nByte\n字节\n8 位（1 个字节）\n$-2^7$~$（2^7-1）$\nvar b : Byte = 1\n\n\nShort\n短整型\n16 位（2 个字节）\n$-2^15$~$（2^15-1）$\nvar s : Short = 1\n\n\nInt\n整型\n32 位（4 个字节）\n$-2^31$~$（2^31-1）$\nvar i : Int = 1\n\n\nLong\n长整型\n64 位（8 个字节）\n$-2^63$~$（2^63-1）$\nvar l : Long = 1L\n\n\nFloat\n浮点型\n32 位（4 个字节）\n$1.4E-45$$3.4E+38$，$-3.4E+38$$-1.4E-45$\nvar f : Float = 1f\n\n\nDouble\n双精度浮点型\n64 位（8 个字节）\n$4.9E-324$$1.7E+308$，$-1.7E+308$$-4.9E-324$\nvar d : Double = 1.0\n\n\n在为Long类型赋值时，值末尾要加大写的L，在对 Float 和 Double 类型进行储存时，$E$ 代表以 10 为底的指数，$E$ 后的 $+$，$-$ 表示正指数或负指数，例如 $1.4E-45&#x3D;1.4*10^{-45}$，Float类型赋值后需要在值末尾加大写或小写的f。\n布尔类型在 Kotlin 中使用关键字 Boolean 来表示，只有两个值，分别为 true 和 false。\nvar b : Boolean = true\n\n\n字符类型在 Kotlin 中用于存储单一字符，使用关键字Char表示，赋值时使用一对英文半角格式单引号将字符括起来。\nvar c : Char = 'c'\n\n\n字符串类型在 Kotlin 中用于存储字符串，使用关键字String表示，赋值时使用一对英文半角格式双引号将字符括起来。字符串是不可变的，必须要使用一个新的变量来存储原字符串变换后的值。\nval s : String = \"Crazy THU vivo 50\"\n\nval s1 = s.split(\" \")//不可使用s = s.split(\" \")\n\n字符串的元素可以使用索引运算符访问: s[i]；可以用 for 循环迭代字符串，也可以用+来连接字符串。\nfun main()\n&#123;\n  println(s[1])//结果为'r'\n  for (c in s)\n  &#123;\n      println(c)//每打印一个s中的字符就换一次行\n  &#125;\n  val sNext = s + \" plz\"//sNext = \"Crazy THU vivo 50 plz\"\n&#125;\n\nKotlin 支持在字符串字面值中引用局部变量，只需要在变量名前加上字符$即可，此外还可以包含用花括号&#123;&#125;括起来的表达式，此时会自动求值并把结果合并到字符串中。\nval money = 50\n//直接包含变量\nprintln(\"Crazy THU vivo $money\")//输出结果为\"Crazy THU vivo 50\"\n\n//包含表达式\nprintln(\"(money + 100) is $&#123;money + 100&#125;\")//输出结果为\"(money + 100) is 150\"\n\n在 Kotlin 中，为了方便字符串的查找，提供了多个函数\n\nfirst()&#x2F;&#x2F;查找第一个元素\nlast()&#x2F;&#x2F;查找最后一个元素\nget(index)&#x2F;&#x2F;查找角标为index的元素\nindexOf()&#x2F;&#x2F;查找字符或字符串在原字符串中第一次出现的角标\nlastIndexOf()&#x2F;&#x2F;查找字符或字符串在原字符串中最后一次出现的角标\n\nfun main()\n&#123;\n  var s : String = \"Crazy THU vivo 50\"\n  println(s.first())//输出结果为'C'\n  println(s.last())//输出结果为'0'\n  println(s.get(1))//输出结果为'r'，即第二个元素\n  println(s.indexOf('r'))//输出结果为1\n  println(s.indexOf(\"vivo\"))//输出结果为10\n  println(s.lastIndexOf('r'))//输出结果为1\n  println(s.lastIndexOf(\"vivo\"))//输出结果为10，这里结果也为10是因为字符串以开头第一个字符相对于原字符串的角标为准\n&#125;\n\n字符串的截取：\n\nsubstring()\nsubSequence()\n\nfun main()\n&#123;\n  var s : String = \"Crazy THU vivo 50\"\n  println(s.substring(3))//截取角标为3，到角标结束的字符\n  println(s.substring(3, 7))//截取角标为3，到角标为6的字符\n  println(s.substring(IntRange(3, 7))//截取角标为3，到角标为7的字符\n  println(s.subSequence(3, 7))//截取角标为3，到角标为6的字符，结果强制类型转换为string\n  println(s.subSequence(IntRange(3, 7)))//截取角标为3，到角标为7的字符，结果强制类型转换为string\n&#125;\n\n运行结果\nzy THU vivo 50\nzy T\nzy TH\nzy T\nzy TH\n\n字符串的替换：\n\nreplace()\nreplaceFirst()\nreplaceBefore()\nreplaceAfter()\n\nfun main()\n&#123;\n  var s : String = \"Crazy THU vivo 50, Crazy THU vivo 50!\"\n  println(s.replace(\"THU\", \"MON\"))//完全替换\n  println(s.replaceFirst(\"THU\", \"MON\"))//替换第一个找到的\"THU\"\n  println(s.replaceBefore(\",\", \"Hi\"))//替换第一个找到的\",\"之前的所有字符串\n  println(s.replaceAfter(\"50\", \"!\"))//替换第一个找到的\"50\"之后的所有字符串\n&#125;\n\n运行结果\nCrazy MON vivo 50, Crazy MON vivo 50!\nCrazy MON vivo 50, Crazy THU vivo 50!\nHi, Crazy THU vivo 50!\nCrazy THU vivo 50!\n\n字符串的分隔:\n所使用的方法与 C#中的类似\nfun main()\n&#123;\n  var s : String = \"Crazy.THU.vivo.50.,.Crazy.THU.vivo.50!\"\n  var split1=s.split(\".\")\n  var split2=s.split(\".\", \",\")\n  println(split1)\n  println(split2)\n&#125;\n\n运行结果\n[Crazy, THU, vivo, 50, ,, Crazy, THU, vivo, 50!]\n[Crazy, THU, vivo, 50, , , Crazy, THU, vivo, 50!]\n字符串的字面值\n转义字符串\n转义字符串是使用传统的\\反斜杠方式将字符进行转义。\nfun main()\n&#123;\n  var s : String = \"Crazy THU vivo 50\\nCrazy THU vivo 50!\"\n  println(s)\n&#125;\n运行结果\nCrazy THU vivo 50\nCrazy THU vivo 50!\n原生字符串是使用三对引号把所有字符括起来，原生字符串内就算有转义字符也不会被转义。\nfun main()\n&#123;\n  var s : String = \"\"\"Crazy THU vivo 50\\nCrazy THU vivo 50!\"\"\"\n  println(s)\n&#125;\n运行结果\nCrazy THU vivo 50\\nCrazy THU vivo 50!\n字符串的模板表达式\n所谓的模板表达式就算在字符串中添加占位符，字符串模板表达式由$&#123;变量名/函数/表达式组成&#125;，也可以省略&#123;&#125;，例如$变量名。例如前文提到的例子：\nval money = 50\n//直接包含变量\nprintln(\"Crazy THU vivo $money\")//输出结果为\"Crazy THU vivo 50\"\n\n//包含表达式\nprintln(\"(money + 100) is $&#123;money + 100&#125;\")//输出结果为\"(money + 100) is 150\"\n那可能就有大聪明要问了:“那我就想要在原生字符串中输出这个美元符号咋办？”我知道你很急，但你先别急，在原生字符串中虽然不支持反斜杠转义，但我们可以用这样的方法来解决:\nfun main()\n&#123;\n  var s : String = \"\"\"Crazy THU vivo $&#123;'$'&#125;50\"\"\"\n  println(s)\n&#125;\n运行结果\nCrazy THU vivo $50\n\n\n数组类型数组在 Kotlin 中使用 Array 类来表示，它定义了 get 与 set 函数（按照运算符重载约定这会转变为 []）以及 size 属性，以及一些其他有用的成员函数：\n\narrayOf()\narrayOfNulls()\nemptyArray()\nArray\n\n简而言之，可以使用函数 arrayOf()来创建一个数组并传递元素值给它，例如 arrayOf(1, 2, 3) 创建了 array [1, 2, 3]。或者，函数 arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组，emptyArray()可以创建一个长度为 0 的空数组。\nvar int_array : Array&lt;Int> = arrayOf(1, 2, 3)\n//创建一个长度为3的，类型为整型的，数组内元素分别为1,2,3的数组\nvar int_array_null : arrayOfNulls&lt;Int>(10)\n//创建一个长度为10的，类型为整型的，数组内元素全为null的数组\nvar string_array = emptyArray&lt;String>()\n//创建长度为0的空数组\n\n需要注意的是：\narrayOf()无须指定数组的长度，但需要依次列出每个数组元素。\narrayOfNulls()需要指定数组的长度，数组元素全部被初始化为 null，需要指定数组元素的类型。\nemptyArray()需要指定数组元素的类型\nArray的使用方法会在后续的文章中进行介绍，这里就稍稍略过。\n值得一提的是，在初始化数组类型的变量时，也是可以对数据的类型进行省略的。\nvar int_array = arrayOf(1, 2, 3)\n\n当然，非字符串数组也可以采用这种方法来进行初始化，具体的选择就看个人喜好了。\nvar int_array : IntArray = intArrayOf(1, 2, 3)\n\n","slug":"快速入门 Kotlin","date":"2022-10-24T04:37:11.000Z","categories_index":"Code","tags_index":"Kotlin","author_index":"Kaiyuan Qin"}]