[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-03-09T04:34:08.493Z","categories_index":"","tags_index":"配置方式","author_index":"Kaiyuan Qin"},{"id":"1c3acb343b4f9d341101747d7fd21b89","title":"快速入门Kotlin","content":"快速入门 Kotlin在开始这一切的一切之前，我想你应该已经了解了Kotlin 的基本语法，如果你还不是很了解，可以查看Kotlin 的中文文档来浅浅了解一下。\n变量Kotlin 中的变量分为两种类型，分别为可变变量和不可变变量。\n可变变量使用关键字var来修饰，可以进行多次修改（词源 variable，指可变的）。\n不可变变量使用关键字val来修饰，在初始化后就不可再对其进行修改，相当于一个常量（词源 value，指一个值）。\n那么我们该如何在 Kotlin 中声明变量和给变量赋值呢？方法其实和其他的语言差不多，就是关键字加变量名然后赋值。\n这里先展示几种定义变量的方法，也需要遵守Kotlin 的基本语法，需要记住的是，常量与变量都可以没有初始化值,但是在引用前必须初始化。\nval crazyThu = 50\nval crazyThu : Int = 50\n//不可变变量\n/*-------分割线-------*/\nvar crazyThu= 50\nvar crazyThu : Int = 50\n\nval crazyThu\ncrazyThu = 50\n//可变变量\n\n这时候有学习过其他语言的聪明同学可能就会问：“这不是只有var和val两种变量类型吗，如果不声明变量所存储的数据类型，编译器怎么判断变量储存的数据类型是什么呢？”。\n这就不得不提到 Kotlin 的特色，类型推导机制。下面举个例子来说明一下。\nfun main()\n&#123;\n  val crazyThu = 50\n  println(crazyThu)\n&#125;\n\n可以看到，很神奇啊，我们使用了val关键字定义了变量crazyThu，然后给它赋值 50，这时候你肯定知道，50 是一个Int类型也就是整型的数值，这个推导机制也一样，他这时候根据你给变量赋值的类型，来推断出这个crazyThu变量是一个整型变量。假如你这样写val crazyThu = &quot;vivo50&quot;，给crazyThu赋上一个字符串值，推导机制就会认为crazyThu是一个字符串类型的变量，而当你明确告诉它val crazyThu : Int = 50时，推导机制也就不会去进行推断了。但是需要注意的是，这样定义的变量不可以进行延时赋值操作的。\n下面列举了一些在声明变量和给变量赋值时可能会出现的问题：\n1.当不赋初始值时，不对变量进行具体类型的约束\nfun main()\n&#123;\n  var crazyThu\n  /*当不赋初始值时，不对变量进行具体类型的约束，会造成错误*/\n&#125;\n\n\n2.在同个函数内进行重复定义\nfun main()\n&#123;\n  var crazyThu : Int\n  var crazyThu : String\n  /*不能在同个函数内进行重复定义*/\n&#125;\n\n\nAnd so on…\n\n变量的数据类型数值型\n\n\n类型名\n描述\n占用空间\n存储值范围\n示例\n\n\n\nByte\n字节\n8 位（1 个字节）\n$-2^7$~$（2^7-1）$\nvar b : Byte = 1\n\n\nShort\n短整型\n16 位（2 个字节）\n$-2^15$~$（2^15-1）$\nvar s : Short = 1\n\n\nInt\n整型\n32 位（4 个字节）\n$-2^31$~$（2^31-1）$\nvar i : Int = 1\n\n\nLong\n长整型\n64 位（8 个字节）\n$-2^63$~$（2^63-1）$\nvar l : Long = 1L\n\n\nFloat\n浮点型\n32 位（4 个字节）\n$1.4E-45$$3.4E+38$，$-3.4E+38$$-1.4E-45$\nvar f : Float = 1f\n\n\nDouble\n双精度浮点型\n64 位（8 个字节）\n$4.9E-324$$1.7E+308$，$-1.7E+308$$-4.9E-324$\nvar d : Double = 1.0\n\n\n在为Long类型赋值时，值末尾要加大写的L，在对 Float 和 Double 类型进行储存时，$E$ 代表以 10 为底的指数，$E$ 后的 $+$，$-$ 表示正指数或负指数，例如 $1.4E-45&#x3D;1.4*10^{-45}$，Float类型赋值后需要在值末尾加大写或小写的f。\n布尔类型在 Kotlin 中使用关键字 Boolean 来表示，只有两个值，分别为 true 和 false。\nvar b : Boolean = true\n\n\n字符类型在 Kotlin 中用于存储单一字符，使用关键字Char表示，赋值时使用一对英文半角格式单引号将字符括起来。\nvar c : Char = 'c'\n\n\n字符串类型在 Kotlin 中用于存储字符串，使用关键字String表示，赋值时使用一对英文半角格式双引号将字符括起来。字符串是不可变的，必须要使用一个新的变量来存储原字符串变换后的值。\nval s : String = \"Crazy THU vivo 50\"\n\nval s1 = s.split(\" \")//不可使用s = s.split(\" \")\n\n字符串的元素可以使用索引运算符访问: s[i]；可以用 for 循环迭代字符串，也可以用+来连接字符串。\nfun main()\n&#123;\n  println(s[1])//结果为'r'\n  for (c in s)\n  &#123;\n      println(c)//每打印一个s中的字符就换一次行\n  &#125;\n  val sNext = s + \" plz\"//sNext = \"Crazy THU vivo 50 plz\"\n&#125;\n\nKotlin 支持在字符串字面值中引用局部变量，只需要在变量名前加上字符$即可，此外还可以包含用花括号&#123;&#125;括起来的表达式，此时会自动求值并把结果合并到字符串中。\nval money = 50\n//直接包含变量\nprintln(\"Crazy THU vivo $money\")//输出结果为\"Crazy THU vivo 50\"\n\n//包含表达式\nprintln(\"(money + 100) is $&#123;money + 100&#125;\")//输出结果为\"(money + 100) is 150\"\n\n在 Kotlin 中，为了方便字符串的查找，提供了多个函数\n\nfirst()&#x2F;&#x2F;查找第一个元素\nlast()&#x2F;&#x2F;查找最后一个元素\nget(index)&#x2F;&#x2F;查找角标为index的元素\nindexOf()&#x2F;&#x2F;查找字符或字符串在原字符串中第一次出现的角标\nlastIndexOf()&#x2F;&#x2F;查找字符或字符串在原字符串中最后一次出现的角标\n\nfun main()\n&#123;\n  var s : String = \"Crazy THU vivo 50\"\n  println(s.first())//输出结果为'C'\n  println(s.last())//输出结果为'0'\n  println(s.get(1))//输出结果为'r'，即第二个元素\n  println(s.indexOf('r'))//输出结果为1\n  println(s.indexOf(\"vivo\"))//输出结果为10\n  println(s.lastIndexOf('r'))//输出结果为1\n  println(s.lastIndexOf(\"vivo\"))//输出结果为10，这里结果也为10是因为字符串以开头第一个字符相对于原字符串的角标为准\n&#125;\n\n字符串的截取：\n\nsubstring()\nsubSequence()\n\nfun main()\n&#123;\n  var s : String = \"Crazy THU vivo 50\"\n  println(s.substring(3))//截取角标为3，到角标结束的字符\n  println(s.substring(3, 7))//截取角标为3，到角标为6的字符\n  println(s.substring(IntRange(3, 7))//截取角标为3，到角标为7的字符\n  println(s.subSequence(3, 7))//截取角标为3，到角标为6的字符，结果强制类型转换为string\n  println(s.subSequence(IntRange(3, 7)))//截取角标为3，到角标为7的字符，结果强制类型转换为string\n&#125;\n\n运行结果\nzy THU vivo 50\nzy T\nzy TH\nzy T\nzy TH\n\n字符串的替换：\n\nreplace()\nreplaceFirst()\nreplaceBefore()\nreplaceAfter()\n\nfun main()\n&#123;\n  var s : String = \"Crazy THU vivo 50, Crazy THU vivo 50!\"\n  println(s.replace(\"THU\", \"MON\"))//完全替换\n  println(s.replaceFirst(\"THU\", \"MON\"))//替换第一个找到的\"THU\"\n  println(s.replaceBefore(\",\", \"Hi\"))//替换第一个找到的\",\"之前的所有字符串\n  println(s.replaceAfter(\"50\", \"!\"))//替换第一个找到的\"50\"之后的所有字符串\n&#125;\n\n运行结果\nCrazy MON vivo 50, Crazy MON vivo 50!\nCrazy MON vivo 50, Crazy THU vivo 50!\nHi, Crazy THU vivo 50!\nCrazy THU vivo 50!\n\n字符串的分隔:\n所使用的方法与 C#中的类似\nfun main()\n&#123;\n  var s : String = \"Crazy.THU.vivo.50.,.Crazy.THU.vivo.50!\"\n  var split1=s.split(\".\")\n  var split2=s.split(\".\", \",\")\n  println(split1)\n  println(split2)\n&#125;\n\n运行结果\n[Crazy, THU, vivo, 50, ,, Crazy, THU, vivo, 50!]\n[Crazy, THU, vivo, 50, , , Crazy, THU, vivo, 50!]\n字符串的字面值\n转义字符串\n转义字符串是使用传统的\\反斜杠方式将字符进行转义。\nfun main()\n&#123;\n  var s : String = \"Crazy THU vivo 50\\nCrazy THU vivo 50!\"\n  println(s)\n&#125;\n运行结果\nCrazy THU vivo 50\nCrazy THU vivo 50!\n原生字符串是使用三对引号把所有字符括起来，原生字符串内就算有转义字符也不会被转义。\nfun main()\n&#123;\n  var s : String = \"\"\"Crazy THU vivo 50\\nCrazy THU vivo 50!\"\"\"\n  println(s)\n&#125;\n运行结果\nCrazy THU vivo 50\\nCrazy THU vivo 50!\n字符串的模板表达式\n所谓的模板表达式就算在字符串中添加占位符，字符串模板表达式由$&#123;变量名/函数/表达式组成&#125;，也可以省略&#123;&#125;，例如$变量名。例如前文提到的例子：\nval money = 50\n//直接包含变量\nprintln(\"Crazy THU vivo $money\")//输出结果为\"Crazy THU vivo 50\"\n\n//包含表达式\nprintln(\"(money + 100) is $&#123;money + 100&#125;\")//输出结果为\"(money + 100) is 150\"\n那可能就有大聪明要问了:“那我就想要在原生字符串中输出这个美元符号咋办？”我知道你很急，但你先别急，在原生字符串中虽然不支持反斜杠转义，但我们可以用这样的方法来解决:\nfun main()\n&#123;\n  var s : String = \"\"\"Crazy THU vivo $&#123;'$'&#125;50\"\"\"\n  println(s)\n&#125;\n运行结果\nCrazy THU vivo $50\n\n\n数组类型数组在 Kotlin 中使用 Array 类来表示，它定义了 get 与 set 函数（按照运算符重载约定这会转变为 []）以及 size 属性，以及一些其他有用的成员函数：\n\narrayOf()\narrayOfNulls()\nemptyArray()\nArray\n\n简而言之，可以使用函数 arrayOf()来创建一个数组并传递元素值给它，例如 arrayOf(1, 2, 3) 创建了 array [1, 2, 3]。或者，函数 arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组，emptyArray()可以创建一个长度为 0 的空数组。\nvar int_array : Array&lt;Int> = arrayOf(1, 2, 3)\n//创建一个长度为3的，类型为整型的，数组内元素分别为1,2,3的数组\nvar int_array_null : arrayOfNulls&lt;Int>(10)\n//创建一个长度为10的，类型为整型的，数组内元素全为null的数组\nvar string_array = emptyArray&lt;String>()\n//创建长度为0的空数组\n\n需要注意的是：\narrayOf()无须指定数组的长度，但需要依次列出每个数组元素。\narrayOfNulls()需要指定数组的长度，数组元素全部被初始化为 null，需要指定数组元素的类型。\nemptyArray()需要指定数组元素的类型\nArray的使用方法会在后续的文章中进行介绍，这里就稍稍略过。\n值得一提的是，在初始化数组类型的变量时，也是可以对数据的类型进行省略的。\nvar int_array = arrayOf(1, 2, 3)\n\n当然，非字符串数组也可以采用这种方法来进行初始化，具体的选择就看个人喜好了。\nvar int_array : IntArray = intArrayOf(1, 2, 3)\n\n","slug":"快速入门 Kotlin","date":"2022-10-24T04:37:11.000Z","categories_index":"","tags_index":"kotlin","author_index":"Kaiyuan Qin"}]