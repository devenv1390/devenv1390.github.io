{"title":"Kotlin协程","uid":"2fea1ef2357ec7f028dab0f4a3487a7c","slug":"Kotlin协程","date":"2022-10-26T02:36:06.000Z","updated":"2023-03-10T15:54:27.061Z","comments":true,"path":"api/articles/Kotlin协程.json","keywords":null,"cover":"img/blog/choose_kotlin.png","content":"<h1 id=\"Kotlin-协程\"><a href=\"#Kotlin-协程\" class=\"headerlink\" title=\"Kotlin 协程\"></a>Kotlin 协程</h1><p>Kotlin程序至少会有一个线程，而这个线程也就是我们常说的主线程。程序启动后由Java虚拟机创建主线程，程序结束后由java虚拟机销毁主线程。而我们开发人员创建的各种线程都是子线程。主线程负责管理子线程的启动，挂起，停止等操作。而主线程，在我们应用开发中还有一个名称：<code>UI线程</code>。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>下面通过示例了解一下线程 <code>Thread</code>的作用吧：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">Thread</span><span class=\"token punctuation\">(</span>\n        Runnable <span class=\"token punctuation\">&#123;</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello World\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"delay 1s\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出结果是：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">delay 1s \nHello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>可以看到，我们通过调用线程中的 <code>sleep()</code>方法将整个子线程延时1秒再执行。但主线程是直接执行并输出了 <code>delay 1s</code>，通过这个例子就能很直观地看出子线程与主线程的运行状态。</p>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><p>一般来说，在进行开发的时候，碰到一些需要耗费时间的操作，例如网络IO、文件IO等任务时，这些任务会阻塞线程直到整个任务完成。而线程的阻塞问题除了可以通过开启新的线程来解决问题，还可以通过协程来解决。</p>\n<h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><p>协程是一个可暂停计算的实例。它在概念上类似于一个线程，因为它需要一个代码块来运行，与其他代码同时工作。然而，一个循环程序并不会被绑定到任何特定的线程。它可以在一个线程中暂停执行，在另一个线程中继续执行。协程可以被认为是轻量级的线程，但有一些重要的区别，使其在实际的使用中与线程非常不同。</p>\n<h3 id=\"协程的使用\"><a href=\"#协程的使用\" class=\"headerlink\" title=\"协程的使用\"></a>协程的使用</h3><p>下面我们通过一段代码来感受一下协程的调用：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">&#123;</span> \n    launch <span class=\"token punctuation\">&#123;</span> \n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span> \n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行的结果：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">Hello\nWorld<span class=\"token operator\">!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>让我们来剖析一下这段代码的作用：</p>\n<p><code>launch&#123;&#125;</code>是一个协程构建器。它会启动一个新的协程，让该程序继续独立工作，而不影响其他部分的程序。这就是为什么Hello被首先打印出来。<code>delay()</code>是一个特殊的暂停函数。它可以在一个特定的时间内暂停该协程。暂停一个协程不会阻塞主线程，但允许其他协程运行并使用底层线程来运行代码。<code>runBlocking</code>也是一个建立协程的工具，它连接了普通 <code>fun main()</code>的非协程部分和 <code>runBlocking &#123; ... &#125;</code>花括号内的嵌套部分。<code>CoroutineScope</code>提示就在 <code>runBlocking</code>开头的花括号之后。如果你在这段代码中删除或忘记了 <code>runBlocking</code>，你会在调用 launch 时得到一个错误，因为 <code>launch</code>只在 <code>CoroutineScope</code>上声明。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Unresolved reference: launch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>runBlocking</code>的名字意味着运行它的线程（在本例中是主线程）在调用期间会被阻塞，直到 <code>runBlocking &#123; ... &#125;</code>内的所有程序都完成执行。你会经常看到 <code>runBlocking</code>在应用程序的最顶层使用，而在实际代码中很少使用，因为线程是昂贵的资源，阻塞它们是低效的，而且往往是不受欢迎的。</p>\n<h3 id=\"结构化的并发性\"><a href=\"#结构化的并发性\" class=\"headerlink\" title=\"结构化的并发性\"></a>结构化的并发性</h3><p>协程遵循结构化并发的原则，这意味着新的协程只能在一个特定的 <code>CoroutineScope</code>中启动，这个 <code>CoroutineScope</code>限定了协程的生命周期。上面的例子显示，<code>runBlocking</code>建立了相应的范围，这就是为什么前面的例子会等待直到 <code>World！</code>在一秒钟的延迟后被打印出来才退出进程。在实际应用中，我们将会启动很多的协程。结构化的并发性确保它们不会丢失，也不会泄漏。一个外层作用域在其所有子层的协程完成之前不能完成。结构化的并发性还可以确保代码中的任何错误都被正确地报告，并且永远不会丢失。</p>\n<h3 id=\"提取函数重构\"><a href=\"#提取函数重构\" class=\"headerlink\" title=\"提取函数重构\"></a>提取函数重构</h3><p>让我们把 <code>launch&#123; ... &#125;</code>中的代码块提取到一个单独的函数中。当对这段代码进行 “提取函数 “重构时，你会得到一个带有 <code>suspend modifier</code>的新函数，这是一个挂起函数。挂起函数可以像普通函数一样用在协程内部，但它们的特点是，它们可以反过来使用其他挂起的函数（比如本例中的 <code>delay</code>）来挂起协程的执行。</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">&#123;</span> \n    launch <span class=\"token punctuation\">&#123;</span> <span class=\"token function\">doWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">doWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"作用域构建器\"><a href=\"#作用域构建器\" class=\"headerlink\" title=\"作用域构建器\"></a>作用域构建器</h3><p>除了不同的构建器所提供的协程作用域之外，还可以使用 <code>coroutineScope</code>构建器来声明你自己的作用域。它创建了一个协程作用域，在所有启动的子程序完成之前都不会完成。</p>\n<p><code>runBlocking</code>和 <code>coroutineScope</code>构建器看起来很相似，因为它们都在等待其主程序和所有子程序完成。主要的区别是，<code>runBlocking</code>方法阻断了当前线程的等待，而 <code>coroutineScope</code>只是暂停，释放底层的线程用于其他用途。正是因为这个区别，所以我们可以将 <code>runBlocking</code>看做是一个普通的函数，而 <code>coroutineScope</code>是一个暂停的函数。我们可以从任何暂停函数中使用 <code>coroutineScope</code>。例如，可以将 <code>Hello</code>和 <code>World</code>的并发打印转移到一个暂停的函数 <code>doWorld()</code>中。</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">doWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">doWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> coroutineScope <span class=\"token punctuation\">&#123;</span>  \n    launch <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"作用域构建器和其并发性\"><a href=\"#作用域构建器和其并发性\" class=\"headerlink\" title=\"作用域构建器和其并发性\"></a>作用域构建器和其并发性</h3><p><code>coroutineScope</code>构建器可以在任何暂停函数中使用，以执行多个并发的操作。让我们在一个 <code>doWorld()</code>挂起的函数中启动两个并发的 <code>coroutine</code>。</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">doWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Done\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">doWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> coroutineScope <span class=\"token punctuation\">&#123;</span>\n    launch <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World 2\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n    launch <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World 1\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这两段代码在 <code>launch&#123; ... &#125;</code>同时执行，从开始的一秒钟后，先打印 <code>World 1</code>，从开始的两秒钟后，接着打印 <code>World 2</code>。<code>doWorld()</code>中的一个 <code>coroutineScope</code>只有在这两段代码完成后才会完成，所以 <code>doWorld()</code>执行完所有的协程后返回，而 <code>Done</code>字符串在这之后才被打印出来：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">Hello\nWorld <span class=\"token number\">1</span>\nWorld <span class=\"token number\">2</span>\nDone<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"协程中的显式Job\"><a href=\"#协程中的显式Job\" class=\"headerlink\" title=\"协程中的显式Job\"></a>协程中的显式Job</h3><p>一个 <code>launch coroutine builder</code> 会返回一个 <code>Job</code> 对象，该对象是启动 <code>coroutine</code>的方法，可用于显式地等待其完成。例如，你可以等待协程的完成，然后打印 <code>Done</code>字符串。</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> launch <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>\n    job<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Done\"</span></span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>代码结果如下：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">Hello\nWorld<span class=\"token operator\">!</span>\nDone<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"协程很轻量\"><a href=\"#协程很轻量\" class=\"headerlink\" title=\"协程很轻量\"></a>协程很轻量</h3><p><code>Coroutines</code>比 <code>JVM</code>线程的资源密集度低。使用线程时容易耗尽 <code>JVM</code>可用内存的代码，而使用协程则不会触及资源限制。例如，下面的代码启动了100000个不同的 <code>coroutines</code>，每个 <code>coroutines</code>等待5秒，然后打印一个句号 <code>（&#39;.&#39;）</code>，而消耗的内存非常少。</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token number\">100_000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 启动大量的协程</span>\n        launch <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000L</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\".\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果你用线程编写同样的程序（去掉 <code>runBlocking</code>，用线程代替启动，用 <code>Thread.sleep</code>代替延迟），它很可能会消耗过多的内存，并抛出一个内存不足的错误。</p>\n","feature":true,"text":"Kotlin 协程Kotlin程序至少会有一个线程，而这个线程也就是我们常说的主线程。程序启动后由Java虚拟机创建主线程，程序结束后由java虚拟机销毁主线程。而我们开发人员创建的各种线程都是子线程。主线程负责管理子线程的启动，挂起，停止等操作。而主线程，在我们应用开发中还有一...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"Code","slug":"Code","count":3,"path":"api/categories/Code.json"}],"tags":[{"name":"Kotlin","slug":"Kotlin","count":3,"path":"api/tags/Kotlin.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Kotlin-%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">Kotlin 协程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\">协程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基础概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">协程的使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%B9%B6%E5%8F%91%E6%80%A7\"><span class=\"toc-text\">结构化的并发性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%90%E5%8F%96%E5%87%BD%E6%95%B0%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">提取函数重构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA%E5%99%A8\"><span class=\"toc-text\">作用域构建器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%84%E5%BB%BA%E5%99%A8%E5%92%8C%E5%85%B6%E5%B9%B6%E5%8F%91%E6%80%A7\"><span class=\"toc-text\">作用域构建器和其并发性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%98%BE%E5%BC%8FJob\"><span class=\"toc-text\">协程中的显式Job</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E7%A8%8B%E5%BE%88%E8%BD%BB%E9%87%8F\"><span class=\"toc-text\">协程很轻量</span></a></li></ol></li></ol></li></ol>","author":{"name":"Kaiyuan Qin","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"记录我的成长 </br> 分享我的进步","socials":{"github":"https://github.com/devenv1390","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/5666313"}}}},"mapped":true,"prev_post":{"title":"Kotlin异常处理","uid":"74d4cbb8fd6290f0210df58b022938f4","slug":"Kotlin异常处理","date":"2022-11-10T05:57:28.000Z","updated":"2023-03-10T15:55:18.758Z","comments":true,"path":"api/articles/Kotlin异常处理.json","keywords":null,"cover":"img/blog/choose_kotlin.png","text":"Kotlin异常处理异常类Kotlin 中所有异常类继承自 Throwable 类。 每个异常都有消息、堆栈回溯信息以及可选的原因。 使用 throw 表达式来抛出异常： fun main() &#123; //sampleStart throw Exception(\"Hi Th...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"Code","slug":"Code","count":3,"path":"api/categories/Code.json"}],"tags":[{"name":"Kotlin","slug":"Kotlin","count":3,"path":"api/tags/Kotlin.json"}],"author":{"name":"Kaiyuan Qin","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"记录我的成长 </br> 分享我的进步","socials":{"github":"https://github.com/devenv1390","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/5666313"}}}},"feature":true},"next_post":{"title":"快速入门Kotlin","uid":"1c3acb343b4f9d341101747d7fd21b89","slug":"快速入门 Kotlin","date":"2022-10-24T04:37:11.000Z","updated":"2023-03-10T15:55:25.491Z","comments":true,"path":"api/articles/快速入门 Kotlin.json","keywords":null,"cover":"img/blog/choose_kotlin.png","text":"快速入门 Kotlin在开始这一切的一切之前，我想你应该已经了解了Kotlin 的基本语法，如果你还不是很了解，可以查看Kotlin 的中文文档来浅浅了解一下。 变量Kotlin 中的变量分为两种类型，分别为可变变量和不可变变量。 可变变量使用关键字 var来修饰，可以进行多次修...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"Code","slug":"Code","count":3,"path":"api/categories/Code.json"}],"tags":[{"name":"Kotlin","slug":"Kotlin","count":3,"path":"api/tags/Kotlin.json"}],"author":{"name":"Kaiyuan Qin","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"记录我的成长 </br> 分享我的进步","socials":{"github":"https://github.com/devenv1390","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/5666313"}}}},"feature":true}}