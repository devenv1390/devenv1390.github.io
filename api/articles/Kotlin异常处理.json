{"title":"Kotlin异常处理","uid":"74d4cbb8fd6290f0210df58b022938f4","slug":"Kotlin异常处理","date":"2022-11-10T05:57:28.000Z","updated":"2023-03-10T15:55:18.758Z","comments":true,"path":"api/articles/Kotlin异常处理.json","keywords":null,"cover":"img/blog/choose_kotlin.png","content":"<h1 id=\"Kotlin异常处理\"><a href=\"#Kotlin异常处理\" class=\"headerlink\" title=\"Kotlin异常处理\"></a>Kotlin异常处理</h1><h2 id=\"异常类\"><a href=\"#异常类\" class=\"headerlink\" title=\"异常类\"></a>异常类</h2><p>Kotlin 中所有异常类继承自 <code>Throwable</code> 类。 每个异常都有消息、堆栈回溯信息以及可选的原因。</p>\n<p>使用 <code>throw</code> 表达式来抛出异常：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">//sampleStart</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token function\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hi There!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//sampleEnd</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用 <code>try</code>……<code>catch</code> 表达式来捕获异常：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 一些代码</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> SomeException<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 处理程序</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 可选的 finally 块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以有零到多个 <code>catch</code> 块，<code>finally</code> 块可以省略。 但是 <code>catch</code> 与 <code>finally</code> 块至少需有一个。</p>\n<h3 id=\"Try-是一个表达式\"><a href=\"#Try-是一个表达式\" class=\"headerlink\" title=\"Try 是一个表达式\"></a>Try 是一个表达式</h3><p><code>try</code> 是一个表达式，意味着它可以有一个返回值：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> a<span class=\"token operator\">:</span> Int<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">toInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> NumberFormatException<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>try</code>-表达式的返回值是 <code>try</code> 块中的最后一个表达式或者是（所有）<code>catch</code> 块中的最后一个表达式。 <code>finally</code> 块中的内容不会影响表达式的结果。</p>\n<h2 id=\"受检异常\"><a href=\"#受检异常\" class=\"headerlink\" title=\"受检异常\"></a>受检异常</h2><p>Kotlin 没有受检异常。这其中有很多原因，但我们会提供一个简单的示例 that illustrates why it is the case。</p>\n<p>以下是 JDK 中 <code>StringBuilder</code> 类实现的一个示例接口：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">Appendable <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>CharSequence csq<span class=\"token punctuation\">)</span> throws IOException<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个签名是说，每次我追加一个字符串到一些东西（一个 <code>StringBuilder</code>、某种日志、一个控制台等）上时，我就必须捕获 <code>IOException</code>。 为什么？因为相应实现可能正在执行 IO 操作（<code>Writer</code> 也实现了 <code>Appendable</code>）。 其结果是这种代码随处可见：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n    log<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>IOException e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 必须要安全</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这并不好，看看<a href=\"https://www.oracle.com/technetwork/java/effectivejava-136174.html\">《Effective Java》第三版</a> 第 77 条：<em>不要忽略异常</em> 就知道了。</p>\n<p>Bruce Eckel says this about checked exceptions:</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过一些小程序测试得出的结论是异常规范会同时提高开发者的生产力与代码质量，但是大型软件项目的经验表明一个不同的结论——生产力降低、代码质量很少或没有提高。</p></blockquote>\n<p>And here are some additional thoughts on the matter:</p>\n<ul>\n<li><a href=\"https://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html\">《Java 的受检异常是一个错误》（Java&#39;s checked exceptions were a mistake）</a>（Rod Waldhoff）</li>\n<li><a href=\"https://www.artima.com/intv/handcuffs.html\">《受检异常的烦恼》（The Trouble with Checked Exceptions）</a>（Anders Hejlsberg）</li>\n</ul>\n<p>If you want to alert callers about possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the <code>@Throws</code> annotation. Read more about using this annotation <a href=\"https://book.kotlincn.net/text/java-to-kotlin-interop.html#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8\">for Java</a> and <a href=\"https://book.kotlincn.net/text/native-objc-interop.html#errors-and-exceptions\">for Swift and Objective-C</a>.</p>\n<h2 id=\"Nothing-类型\"><a href=\"#Nothing-类型\" class=\"headerlink\" title=\"Nothing 类型\"></a>Nothing 类型</h2><p>在 Kotlin 中 <code>throw</code> 是表达式，所以你可以使用它（比如）作为 Elvis 表达式的一部分：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> s <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span>name <span class=\"token operator\">?:</span> <span class=\"token keyword\">throw</span> <span class=\"token function\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Name required\"</span></span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>throw</code> 表达式的类型是 <code>Nothing</code> 类型。 这个类型没有值，而是用于标记永远不能达到的代码位置。 在你自己的代码中，你可以使用 <code>Nothing</code> 来标记一个永远不会返回的函数：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">fail</span><span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Nothing <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token function\">IllegalArgumentException</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>当你调用该函数时，编译器会知道在该调用后就不再继续执行了：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> s <span class=\"token operator\">=</span> person<span class=\"token punctuation\">.</span>name <span class=\"token operator\">?:</span> <span class=\"token function\">fail</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Name required\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>     <span class=\"token comment\">// 在此已知“s”已初始化</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>当处理类型推断时还可能会遇到这个类型。这个类型的可空变体 <code>Nothing?</code> 有一个可能的值是 <code>null</code>。如果用 <code>null</code> 来初始化一个要推断类型的值，而又没有其他信息可用于确定更具体的类型时，编译器会推断出 <code>Nothing?</code> 类型：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> x <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>           <span class=\"token comment\">// “x”具有类型 `Nothing?`</span>\n<span class=\"token keyword\">val</span> l <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">// “l”具有类型 `List&lt;Nothing?></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n","feature":true,"text":"Kotlin异常处理异常类Kotlin 中所有异常类继承自 Throwable 类。 每个异常都有消息、堆栈回溯信息以及可选的原因。 使用 throw 表达式来抛出异常： fun main() &#123; //sampleStart throw Exception(\"Hi Th...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"Code","slug":"Code","count":3,"path":"api/categories/Code.json"}],"tags":[{"name":"Kotlin","slug":"Kotlin","count":3,"path":"api/tags/Kotlin.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Kotlin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">Kotlin异常处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E7%B1%BB\"><span class=\"toc-text\">异常类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Try-%E6%98%AF%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">Try 是一个表达式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">受检异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nothing-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Nothing 类型</span></a></li></ol></li></ol>","author":{"name":"Kaiyuan Qin","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"记录我的成长 </br> 分享我的进步","socials":{"github":"https://github.com/devenv1390","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/5666313"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Kotlin协程","uid":"2fea1ef2357ec7f028dab0f4a3487a7c","slug":"Kotlin协程","date":"2022-10-26T02:36:06.000Z","updated":"2023-03-10T15:54:27.061Z","comments":true,"path":"api/articles/Kotlin协程.json","keywords":null,"cover":"img/blog/choose_kotlin.png","text":"Kotlin 协程Kotlin程序至少会有一个线程，而这个线程也就是我们常说的主线程。程序启动后由Java虚拟机创建主线程，程序结束后由java虚拟机销毁主线程。而我们开发人员创建的各种线程都是子线程。主线程负责管理子线程的启动，挂起，停止等操作。而主线程，在我们应用开发中还有一...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"Code","slug":"Code","count":3,"path":"api/categories/Code.json"}],"tags":[{"name":"Kotlin","slug":"Kotlin","count":3,"path":"api/tags/Kotlin.json"}],"author":{"name":"Kaiyuan Qin","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"记录我的成长 </br> 分享我的进步","socials":{"github":"https://github.com/devenv1390","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/img/bilibili.png","link":"https://space.bilibili.com/5666313"}}}},"feature":true}}