<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>//post/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>配置方式</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin异常处理</title>
    <url>//post/Kotlin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<h1 id="Kotlin异常处理"><a href="#Kotlin异常处理" class="headerlink" title="Kotlin异常处理"></a>Kotlin异常处理</h1><h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><p>Kotlin 中所有异常类继承自 <code>Throwable</code> 类。 每个异常都有消息、堆栈回溯信息以及可选的原因。</p>
<p>使用 <code>throw</code> 表达式来抛出异常：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token comment">//sampleStart</span>
    <span class="token keyword">throw</span> <span class="token function">Exception</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hi There!"</span></span><span class="token punctuation">)</span>
<span class="token comment">//sampleEnd</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 <code>try</code>……<code>catch</code> 表达式来捕获异常：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 一些代码</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> SomeException<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 处理程序</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 可选的 finally 块</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以有零到多个 <code>catch</code> 块，<code>finally</code> 块可以省略。 但是 <code>catch</code> 与 <code>finally</code> 块至少需有一个。</p>
<h3 id="Try-是一个表达式"><a href="#Try-是一个表达式" class="headerlink" title="Try 是一个表达式"></a>Try 是一个表达式</h3><p><code>try</code> 是一个表达式，意味着它可以有一个返回值：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> a<span class="token operator">:</span> Int<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> input<span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> NumberFormatException<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">null</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>try</code>-表达式的返回值是 <code>try</code> 块中的最后一个表达式或者是（所有）<code>catch</code> 块中的最后一个表达式。 <code>finally</code> 块中的内容不会影响表达式的结果。</p>
<h2 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h2><p>Kotlin 没有受检异常。这其中有很多原因，但我们会提供一个简单的示例 that illustrates why it is the case。</p>
<p>以下是 JDK 中 <code>StringBuilder</code> 类实现的一个示例接口：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">Appendable <span class="token function">append</span><span class="token punctuation">(</span>CharSequence csq<span class="token punctuation">)</span> throws IOException<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个签名是说，每次我追加一个字符串到一些东西（一个 <code>StringBuilder</code>、某种日志、一个控制台等）上时，我就必须捕获 <code>IOException</code>。 为什么？因为相应实现可能正在执行 IO 操作（<code>Writer</code> 也实现了 <code>Appendable</code>）。 其结果是这种代码随处可见：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    log<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 必须要安全</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这并不好，看看<a href="https://www.oracle.com/technetwork/java/effectivejava-136174.html">《Effective Java》第三版</a> 第 77 条：<em>不要忽略异常</em> 就知道了。</p>
<p>Bruce Eckel says this about checked exceptions:</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>通过一些小程序测试得出的结论是异常规范会同时提高开发者的生产力与代码质量，但是大型软件项目的经验表明一个不同的结论——生产力降低、代码质量很少或没有提高。</p></blockquote>
<p>And here are some additional thoughts on the matter:</p>
<ul>
<li><a href="https://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html">《Java 的受检异常是一个错误》（Java&#39;s checked exceptions were a mistake）</a>（Rod Waldhoff）</li>
<li><a href="https://www.artima.com/intv/handcuffs.html">《受检异常的烦恼》（The Trouble with Checked Exceptions）</a>（Anders Hejlsberg）</li>
</ul>
<p>If you want to alert callers about possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the <code>@Throws</code> annotation. Read more about using this annotation <a href="https://book.kotlincn.net/text/java-to-kotlin-interop.html#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8">for Java</a> and <a href="https://book.kotlincn.net/text/native-objc-interop.html#errors-and-exceptions">for Swift and Objective-C</a>.</p>
<h2 id="Nothing-类型"><a href="#Nothing-类型" class="headerlink" title="Nothing 类型"></a>Nothing 类型</h2><p>在 Kotlin 中 <code>throw</code> 是表达式，所以你可以使用它（比如）作为 Elvis 表达式的一部分：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> s <span class="token operator">=</span> person<span class="token punctuation">.</span>name <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Name required"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>throw</code> 表达式的类型是 <code>Nothing</code> 类型。 这个类型没有值，而是用于标记永远不能达到的代码位置。 在你自己的代码中，你可以使用 <code>Nothing</code> 来标记一个永远不会返回的函数：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">fail</span><span class="token punctuation">(</span>message<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Nothing <span class="token punctuation">&#123;</span>
    <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>当你调用该函数时，编译器会知道在该调用后就不再继续执行了：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> s <span class="token operator">=</span> person<span class="token punctuation">.</span>name <span class="token operator">?:</span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Name required"</span></span><span class="token punctuation">)</span>
<span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>     <span class="token comment">// 在此已知“s”已初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当处理类型推断时还可能会遇到这个类型。这个类型的可空变体 <code>Nothing?</code> 有一个可能的值是 <code>null</code>。如果用 <code>null</code> 来初始化一个要推断类型的值，而又没有其他信息可用于确定更具体的类型时，编译器会推断出 <code>Nothing?</code> 类型：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> x <span class="token operator">=</span> <span class="token keyword">null</span>           <span class="token comment">// “x”具有类型 `Nothing?`</span>
<span class="token keyword">val</span> l <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>   <span class="token comment">// “l”具有类型 `List&lt;Nothing?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin协程</title>
    <url>//post/Kotlin%E5%8D%8F%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="Kotlin-协程"><a href="#Kotlin-协程" class="headerlink" title="Kotlin 协程"></a>Kotlin 协程</h1><p>Kotlin程序至少会有一个线程，而这个线程也就是我们常说的主线程。程序启动后由Java虚拟机创建主线程，程序结束后由java虚拟机销毁主线程。而我们开发人员创建的各种线程都是子线程。主线程负责管理子线程的启动，挂起，停止等操作。而主线程，在我们应用开发中还有一个名称：<code>UI线程</code>。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>下面通过示例了解一下线程 <code>Thread</code>的作用吧：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Thread</span><span class="token punctuation">(</span>
        Runnable <span class="token punctuation">&#123;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hello World"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"delay 1s"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果是：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">delay 1s 
Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，我们通过调用线程中的 <code>sleep()</code>方法将整个子线程延时1秒再执行。但主线程是直接执行并输出了 <code>delay 1s</code>，通过这个例子就能很直观地看出子线程与主线程的运行状态。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>一般来说，在进行开发的时候，碰到一些需要耗费时间的操作，例如网络IO、文件IO等任务时，这些任务会阻塞线程直到整个任务完成。而线程的阻塞问题除了可以通过开启新的线程来解决问题，还可以通过协程来解决。</p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>协程是一个可暂停计算的实例。它在概念上类似于一个线程，因为它需要一个代码块来运行，与其他代码同时工作。然而，一个循环程序并不会被绑定到任何特定的线程。它可以在一个线程中暂停执行，在另一个线程中继续执行。协程可以被认为是轻量级的线程，但有一些重要的区别，使其在实际的使用中与线程非常不同。</p>
<h3 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h3><p>下面我们通过一段代码来感受一下协程的调用：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">&#123;</span> 
    launch <span class="token punctuation">&#123;</span> 
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span> 
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"World!"</span></span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#125;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行的结果：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">Hello
World<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>让我们来剖析一下这段代码的作用：</p>
<p><code>launch&#123;&#125;</code>是一个协程构建器。它会启动一个新的协程，让该程序继续独立工作，而不影响其他部分的程序。这就是为什么Hello被首先打印出来。<code>delay()</code>是一个特殊的暂停函数。它可以在一个特定的时间内暂停该协程。暂停一个协程不会阻塞主线程，但允许其他协程运行并使用底层线程来运行代码。<code>runBlocking</code>也是一个建立协程的工具，它连接了普通 <code>fun main()</code>的非协程部分和 <code>runBlocking &#123; ... &#125;</code>花括号内的嵌套部分。<code>CoroutineScope</code>提示就在 <code>runBlocking</code>开头的花括号之后。如果你在这段代码中删除或忘记了 <code>runBlocking</code>，你会在调用 launch 时得到一个错误，因为 <code>launch</code>只在 <code>CoroutineScope</code>上声明。</p>
<pre class="line-numbers language-none"><code class="language-none">Unresolved reference: launch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>runBlocking</code>的名字意味着运行它的线程（在本例中是主线程）在调用期间会被阻塞，直到 <code>runBlocking &#123; ... &#125;</code>内的所有程序都完成执行。你会经常看到 <code>runBlocking</code>在应用程序的最顶层使用，而在实际代码中很少使用，因为线程是昂贵的资源，阻塞它们是低效的，而且往往是不受欢迎的。</p>
<h3 id="结构化的并发性"><a href="#结构化的并发性" class="headerlink" title="结构化的并发性"></a>结构化的并发性</h3><p>协程遵循结构化并发的原则，这意味着新的协程只能在一个特定的 <code>CoroutineScope</code>中启动，这个 <code>CoroutineScope</code>限定了协程的生命周期。上面的例子显示，<code>runBlocking</code>建立了相应的范围，这就是为什么前面的例子会等待直到 <code>World！</code>在一秒钟的延迟后被打印出来才退出进程。在实际应用中，我们将会启动很多的协程。结构化的并发性确保它们不会丢失，也不会泄漏。一个外层作用域在其所有子层的协程完成之前不能完成。结构化的并发性还可以确保代码中的任何错误都被正确地报告，并且永远不会丢失。</p>
<h3 id="提取函数重构"><a href="#提取函数重构" class="headerlink" title="提取函数重构"></a>提取函数重构</h3><p>让我们把 <code>launch&#123; ... &#125;</code>中的代码块提取到一个单独的函数中。当对这段代码进行 “提取函数 “重构时，你会得到一个带有 <code>suspend modifier</code>的新函数，这是一个挂起函数。挂起函数可以像普通函数一样用在协程内部，但它们的特点是，它们可以反过来使用其他挂起的函数（比如本例中的 <code>delay</code>）来挂起协程的执行。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">&#123;</span> 
    launch <span class="token punctuation">&#123;</span> <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"World!"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h3><p>除了不同的构建器所提供的协程作用域之外，还可以使用 <code>coroutineScope</code>构建器来声明你自己的作用域。它创建了一个协程作用域，在所有启动的子程序完成之前都不会完成。</p>
<p><code>runBlocking</code>和 <code>coroutineScope</code>构建器看起来很相似，因为它们都在等待其主程序和所有子程序完成。主要的区别是，<code>runBlocking</code>方法阻断了当前线程的等待，而 <code>coroutineScope</code>只是暂停，释放底层的线程用于其他用途。正是因为这个区别，所以我们可以将 <code>runBlocking</code>看做是一个普通的函数，而 <code>coroutineScope</code>是一个暂停的函数。我们可以从任何暂停函数中使用 <code>coroutineScope</code>。例如，可以将 <code>Hello</code>和 <code>World</code>的并发打印转移到一个暂停的函数 <code>doWorld()</code>中。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">&#123;</span>
    <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> coroutineScope <span class="token punctuation">&#123;</span>  
    launch <span class="token punctuation">&#123;</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"World!"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="作用域构建器和其并发性"><a href="#作用域构建器和其并发性" class="headerlink" title="作用域构建器和其并发性"></a>作用域构建器和其并发性</h3><p><code>coroutineScope</code>构建器可以在任何暂停函数中使用，以执行多个并发的操作。让我们在一个 <code>doWorld()</code>挂起的函数中启动两个并发的 <code>coroutine</code>。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">&#123;</span>
    <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Done"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">doWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> coroutineScope <span class="token punctuation">&#123;</span>
    launch <span class="token punctuation">&#123;</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000L</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"World 2"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    launch <span class="token punctuation">&#123;</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"World 1"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这两段代码在 <code>launch&#123; ... &#125;</code>同时执行，从开始的一秒钟后，先打印 <code>World 1</code>，从开始的两秒钟后，接着打印 <code>World 2</code>。<code>doWorld()</code>中的一个 <code>coroutineScope</code>只有在这两段代码完成后才会完成，所以 <code>doWorld()</code>执行完所有的协程后返回，而 <code>Done</code>字符串在这之后才被打印出来：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">Hello
World <span class="token number">1</span>
World <span class="token number">2</span>
Done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="协程中的显式Job"><a href="#协程中的显式Job" class="headerlink" title="协程中的显式Job"></a>协程中的显式Job</h3><p>一个 <code>launch coroutine builder</code> 会返回一个 <code>Job</code> 对象，该对象是启动 <code>coroutine</code>的方法，可用于显式地等待其完成。例如，你可以等待协程的完成，然后打印 <code>Done</code>字符串。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">&#123;</span>
    <span class="token keyword">val</span> job <span class="token operator">=</span> launch <span class="token punctuation">&#123;</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"World!"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Hello"</span></span><span class="token punctuation">)</span>
    job<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Done"</span></span><span class="token punctuation">)</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码结果如下：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">Hello
World<span class="token operator">!</span>
Done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="协程很轻量"><a href="#协程很轻量" class="headerlink" title="协程很轻量"></a>协程很轻量</h3><p><code>Coroutines</code>比 <code>JVM</code>线程的资源密集度低。使用线程时容易耗尽 <code>JVM</code>可用内存的代码，而使用协程则不会触及资源限制。例如，下面的代码启动了100000个不同的 <code>coroutines</code>，每个 <code>coroutines</code>等待5秒，然后打印一个句号 <code>（&#39;.&#39;）</code>，而消耗的内存非常少。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">&#123;</span>
    <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">100_000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 启动大量的协程</span>
        launch <span class="token punctuation">&#123;</span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">5000L</span><span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"."</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果你用线程编写同样的程序（去掉 <code>runBlocking</code>，用线程代替启动，用 <code>Thread.sleep</code>代替延迟），它很可能会消耗过多的内存，并抛出一个内存不足的错误。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>快速入门Kotlin</title>
    <url>//post/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%20Kotlin.html</url>
    <content><![CDATA[<h1 id="快速入门-Kotlin"><a href="#快速入门-Kotlin" class="headerlink" title="快速入门 Kotlin"></a>快速入门 Kotlin</h1><p>在开始这一切的一切之前，我想你应该已经了解了<a href="%E5%9C%A8Kotlin%E4%B8%AD%EF%BC%8C%E7%A8%8B%E5%BA%8F%E9%83%BD%E4%BC%9A%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AAmain()%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BD%9C%E4%B8%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E5%8F%A3%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BC%9A%E5%8C%85%E5%90%AB%E4%B8%80%E4%BA%9B%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82" title="Kotlin的基本语法">Kotlin 的基本语法</a>，如果你还不是很了解，可以查看<a href="%5Bhttps://book.kotlincn.net/text/basic-syntax.html%5D(https://book.kotlincn.net/text/basic-syntax.html)" title="Kotlin 中文文档">Kotlin 的中文文档</a>来浅浅了解一下。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><p>Kotlin 中的变量分为两种类型，分别为<strong>可变变量</strong>和<strong>不可变变量</strong>。</p>
<h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a><strong>可变变量</strong></h3><p>使用关键字 <code>var</code>来修饰，可以进行多次修改（词源 variable，指可变的）。</p>
<h3 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a><strong>不可变变量</strong></h3><p>使用关键字 <code>val</code>来修饰，在初始化后就不可再对其进行修改，相当于一个常量（词源 value，指一个值）。</p>
<h3 id="那么我们该如何在-Kotlin-中声明变量和给变量赋值呢？"><a href="#那么我们该如何在-Kotlin-中声明变量和给变量赋值呢？" class="headerlink" title="那么我们该如何在 Kotlin 中声明变量和给变量赋值呢？"></a>那么我们该如何在 Kotlin 中声明变量和给变量赋值呢？</h3><p>方法其实和其他的语言差不多，就是关键字加变量名然后赋值。</p>
<p>这里先展示几种定义变量的方法，也需要遵守<a href="%E5%9C%A8Kotlin%E4%B8%AD%EF%BC%8C%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E8%AF%BE%E5%88%86%E4%B8%BA%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%8A%9F%E8%83%BD%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%EF%BC%8C%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5%E7%94%A8%E4%BA%8E%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8A%9F%E8%83%BD%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E7%94%A8%E4%BA%8E%E5%AE%9E%E7%8E%B0%E5%85%B7%E4%BD%93%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%AF%8F%E6%9D%A1%E5%8D%95%E8%A1%8C%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E5%90%8E%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%E8%8B%B1%E6%96%87%E5%8D%8A%E8%A7%92%E5%88%86%E5%8F%B7(;)%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%9C%89%E4%B8%A4%E6%9D%A1%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%88%99%E9%9C%80%E8%A6%81%E7%94%A8%E8%8B%B1%E6%96%87%E5%8D%8A%E8%A7%92%E5%88%86%E5%8F%B7%E5%B0%86%E5%85%B6%E5%88%86%E9%9A%94%E5%BC%80%E3%80%82" title="Kotlin的基本语法">Kotlin 的基本语法</a>，需要记住的是，常量与变量都可以没有初始化值,但是在引用前必须初始化。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> crazyThu <span class="token operator">=</span> <span class="token number">50</span>
<span class="token keyword">val</span> crazyThu <span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">50</span>
<span class="token comment">//不可变变量</span>
<span class="token comment">/*-------分割线-------*/</span>
<span class="token keyword">var</span> crazyThu<span class="token operator">=</span> <span class="token number">50</span>
<span class="token keyword">var</span> crazyThu <span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">50</span>

<span class="token keyword">val</span> crazyThu
crazyThu <span class="token operator">=</span> <span class="token number">50</span>
<span class="token comment">//可变变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这时候有学习过其他语言的聪明同学可能就会问：“这不是只有 <code>var</code>和 <code>val</code>两种变量类型吗，如果不声明变量所存储的数据类型，编译器怎么判断变量储存的数据类型是什么呢？”。</p>
<p>这就不得不提到 Kotlin 的特色，类型推导机制。下面举个例子来说明一下。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">val</span> crazyThu <span class="token operator">=</span> <span class="token number">50</span>
  <span class="token function">println</span><span class="token punctuation">(</span>crazyThu<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，很神奇啊，我们使用了 <code>val</code>关键字定义了变量 <code>crazyThu</code>，然后给它赋值 50，这时候你肯定知道，50 是一个 <code>Int</code>类型也就是整型的数值，这个推导机制也一样，他这时候根据你给变量赋值的类型，来推断出这个 <code>crazyThu</code>变量是一个整型变量。假如你这样写 <code>val crazyThu = &quot;vivo50&quot;</code>，给 <code>crazyThu</code>赋上一个字符串值，推导机制就会认为 <code>crazyThu</code>是一个字符串类型的变量，而当你明确告诉它 <code>val crazyThu : Int = 50</code>时，推导机制也就不会去进行推断了。但是需要注意的是，这样定义的变量不可以进行延时赋值操作的。</p>
<p>下面列举了一些在声明变量和给变量赋值时可能会出现的问题：</p>
<p>1.当不赋初始值时，不对变量进行具体类型的约束</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> crazyThu
  <span class="token comment">/*当不赋初始值时，不对变量进行具体类型的约束，会造成错误*/</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<p>2.在同个函数内进行重复定义</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> crazyThu <span class="token operator">:</span> Int
  <span class="token keyword">var</span> crazyThu <span class="token operator">:</span> String
  <span class="token comment">/*不能在同个函数内进行重复定义*/</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<p>And so on…</p>
<hr>
<h2 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h2><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><table>
<thead>
<tr>
<th>类型名</th>
<th>描述</th>
<th>占用空间</th>
<th>存储值范围</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Byte</strong></td>
<td>字节</td>
<td>8 位（1 个字节）</td>
<td>$-2^7$~$（2^7-1）$</td>
<td><strong><code>var b : Byte = 1</code></strong></td>
</tr>
<tr>
<td><strong>Short</strong></td>
<td>短整型</td>
<td>16 位（2 个字节）</td>
<td>$-2^15$~$（2^15-1）$</td>
<td><strong><code>var s : Short = 1</code></strong></td>
</tr>
<tr>
<td><strong>Int</strong></td>
<td>整型</td>
<td>32 位（4 个字节）</td>
<td>$-2^31$~$（2^31-1）$</td>
<td><strong><code>var i : Int = 1</code></strong></td>
</tr>
<tr>
<td><strong>Long</strong></td>
<td>长整型</td>
<td>64 位（8 个字节）</td>
<td>$-2^63$~$（2^63-1）$</td>
<td><strong><code>var l : Long = 1L</code></strong></td>
</tr>
<tr>
<td><strong>Float</strong></td>
<td>浮点型</td>
<td>32 位（4 个字节）</td>
<td>$1.4E-45$<del>$3.4E+38$，$-3.4E+38$</del>$-1.4E-45$</td>
<td><strong><code>var f : Float = 1f</code></strong></td>
</tr>
<tr>
<td><strong>Double</strong></td>
<td>双精度浮点型</td>
<td>64 位（8 个字节）</td>
<td>$4.9E-324$<del>$1.7E+308$，$-1.7E+308$</del>$-4.9E-324$</td>
<td><strong><code>var d : Double = 1.0</code></strong></td>
</tr>
</tbody></table>
<p>在为<strong>Long</strong>类型赋值时，值末尾要加大写的<strong>L</strong>，在对 Float 和 Double 类型进行储存时，$E$ 代表以 10 为底的指数，$E$ 后的 $+$，$-$ 表示正指数或负指数，例如 $1.4E-45&#x3D;1.4*10^{-45}$，<strong>Float</strong>类型赋值后需要在值末尾加大写或小写的<strong>f</strong>。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>在 Kotlin 中使用关键字 <strong>Boolean</strong> 来表示，只有两个值，分别为 true 和 false。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> b <span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>在 Kotlin 中用于存储单一字符，使用关键字<strong>Char</strong>表示，赋值时使用一对英文半角格式单引号将字符括起来。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> c <span class="token operator">:</span> Char <span class="token operator">=</span> <span class="token char">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>在 Kotlin 中用于存储字符串，使用关键字<strong>String</strong>表示，赋值时使用一对英文半角格式双引号将字符括起来。字符串是不可变的，必须要使用一个新的变量来存储原字符串变换后的值。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> s <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Crazy THU vivo 50"</span></span>

<span class="token keyword">val</span> s1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">" "</span></span><span class="token punctuation">)</span><span class="token comment">//不可使用s = s.split(" ")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>字符串的元素可以使用索引运算符访问: <code>s[i]</code>；可以用 <code>for</code> 循环迭代字符串，也可以用 <code>+</code>来连接字符串。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//结果为'r'</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>c <span class="token keyword">in</span> s<span class="token punctuation">)</span>
  <span class="token punctuation">&#123;</span>
      <span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token comment">//每打印一个s中的字符就换一次行</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">val</span> sNext <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token string-literal singleline"><span class="token string">" plz"</span></span><span class="token comment">//sNext = "Crazy THU vivo 50 plz"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Kotlin 支持在字符串字面值中引用局部变量，只需要在变量名前加上字符 <code>$</code>即可，此外还可以包含用花括号 <code>&#123;&#125;</code>括起来的表达式，此时会自动求值并把结果合并到字符串中。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> money <span class="token operator">=</span> <span class="token number">50</span>
<span class="token comment">//直接包含变量</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Crazy THU vivo </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">money</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token comment">//输出结果为"Crazy THU vivo 50"</span>

<span class="token comment">//包含表达式</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"(money + 100) is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token expression">money <span class="token operator">+</span> <span class="token number">100</span></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token comment">//输出结果为"(money + 100) is 150"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 Kotlin 中，为了方便字符串的<strong>查找</strong>，提供了多个函数</p>
<ol>
<li><code>first()</code>&#x2F;&#x2F;查找第一个元素</li>
<li><code>last()</code>&#x2F;&#x2F;查找最后一个元素</li>
<li><code>get(index)</code>&#x2F;&#x2F;查找角标为<em>index</em>的元素</li>
<li><code>indexOf()</code>&#x2F;&#x2F;查找字符或字符串在原字符串中第一次出现的角标</li>
<li><code>lastIndexOf()</code>&#x2F;&#x2F;查找字符或字符串在原字符串中最后一次出现的角标</li>
</ol>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> s <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Crazy THU vivo 50"</span></span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出结果为'C'</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出结果为'0'</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出结果为'r'，即第二个元素</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token char">'r'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出结果为1</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"vivo"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出结果为10</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token char">'r'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出结果为1</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"vivo"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//输出结果为10，这里结果也为10是因为字符串以开头第一个字符相对于原字符串的角标为准</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>字符串的<strong>截取</strong>：</p>
<ol>
<li><code>substring()</code></li>
<li><code>subSequence()</code></li>
</ol>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> s <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Crazy THU vivo 50"</span></span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//截取角标为3，到角标结束的字符</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//截取角标为3，到角标为6的字符</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token function">IntRange</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//截取角标为3，到角标为7的字符</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">subSequence</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//截取角标为3，到角标为6的字符，结果强制类型转换为string</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">subSequence</span><span class="token punctuation">(</span><span class="token function">IntRange</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//截取角标为3，到角标为7的字符，结果强制类型转换为string</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">运行结果
zy THU vivo <span class="token number">50</span>
zy T
zy TH
zy T
zy TH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>字符串的<strong>替换</strong>：</p>
<ol>
<li><code>replace()</code></li>
<li><code>replaceFirst()</code></li>
<li><code>replaceBefore()</code></li>
<li><code>replaceAfter()</code></li>
</ol>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> s <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Crazy THU vivo 50, Crazy THU vivo 50!"</span></span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"THU"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"MON"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//完全替换</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">replaceFirst</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"THU"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"MON"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//替换第一个找到的"THU"</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">replaceBefore</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">","</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"Hi"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//替换第一个找到的","之前的所有字符串</span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">replaceAfter</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"50"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"!"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//替换第一个找到的"50"之后的所有字符串</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">运行结果
Crazy MON vivo <span class="token number">50</span><span class="token punctuation">,</span> Crazy MON vivo <span class="token number">50</span><span class="token operator">!</span>
Crazy MON vivo <span class="token number">50</span><span class="token punctuation">,</span> Crazy THU vivo <span class="token number">50</span><span class="token operator">!</span>
Hi<span class="token punctuation">,</span> Crazy THU vivo <span class="token number">50</span><span class="token operator">!</span>
Crazy THU vivo <span class="token number">50</span><span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>字符串的<strong>分隔</strong>:</p>
<p>所使用的方法与 C#中的类似</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> s <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Crazy.THU.vivo.50.,.Crazy.THU.vivo.50!"</span></span>
  <span class="token keyword">var</span> split1<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"."</span></span><span class="token punctuation">)</span>
  <span class="token keyword">var</span> split2<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"."</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">","</span></span><span class="token punctuation">)</span>
  <span class="token function">println</span><span class="token punctuation">(</span>split1<span class="token punctuation">)</span>
  <span class="token function">println</span><span class="token punctuation">(</span>split2<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">运行结果
<span class="token punctuation">[</span>Crazy<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> vivo<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token punctuation">,</span><span class="token punctuation">,</span> Crazy<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> vivo<span class="token punctuation">,</span> <span class="token number">50</span><span class="token operator">!</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>Crazy<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> vivo<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token punctuation">,</span> Crazy<span class="token punctuation">,</span> THU<span class="token punctuation">,</span> vivo<span class="token punctuation">,</span> <span class="token number">50</span><span class="token operator">!</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>字符串的<strong>字面值</strong></p>
<p><strong>转义字符串</strong></p>
<p><strong>转义字符串</strong>是使用传统的 <code>\</code>反斜杠方式将字符进行转义。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> s <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">"Crazy THU vivo 50\nCrazy THU vivo 50!"</span></span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">运行结果
Crazy THU vivo <span class="token number">50</span>
Crazy THU vivo <span class="token number">50</span><span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>原生字符串</strong>是使用三对引号把所有字符括起来，原生字符串内就算有转义字符也不会被转义。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> s <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal multiline"><span class="token string">"""Crazy THU vivo 50\nCrazy THU vivo 50!"""</span></span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">运行结果
Crazy THU vivo <span class="token number">50</span>\nCrazy THU vivo <span class="token number">50</span><span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>字符串的<strong>模板表达式</strong></p>
<p>所谓的模板表达式就算在字符串中添加占位符，字符串模板表达式由 <code>$&#123;变量名/函数/表达式组成&#125;</code>，也可以省略 <code>&#123;&#125;</code>，例如 <code>$变量名</code>。例如前文提到的例子：</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">val</span> money <span class="token operator">=</span> <span class="token number">50</span>
<span class="token comment">//直接包含变量</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Crazy THU vivo </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">money</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token comment">//输出结果为"Crazy THU vivo 50"</span>

<span class="token comment">//包含表达式</span>
<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"(money + 100) is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token expression">money <span class="token operator">+</span> <span class="token number">100</span></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token comment">//输出结果为"(money + 100) is 150"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那可能就有大聪明要问了:“那我就想要在原生字符串中输出这个美元符号咋办？”<br><del>我知道你很急，但你先别急，</del>在<strong>原生字符串中</strong>虽然不支持反斜杠转义，但我们可以用这样的方法来解决:</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> s <span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string-literal multiline"><span class="token string">"""Crazy THU vivo </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token expression"><span class="token char">'$'</span></span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">50"""</span></span>
  <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin">运行结果
Crazy THU vivo $<span class="token number">50</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组在 Kotlin 中使用 <code>Array</code> 类来表示，它定义了 <code>get</code> 与 <code>set</code> 函数（按照运算符重载约定这会转变为 <code>[]</code>）以及 <code>size</code> 属性，以及一些其他有用的成员函数：</p>
<ol>
<li><code>arrayOf()</code></li>
<li><code>arrayOfNulls()</code></li>
<li><code>emptyArray()</code></li>
<li><code>Array</code></li>
</ol>
<p><strong>简而言之</strong>，可以使用函数 <code>arrayOf()</code>来创建一个数组并传递元素值给它，例如 <code>arrayOf(1, 2, 3)</code> 创建了 <code>array [1, 2, 3]</code>。或者，函数 <code>arrayOfNulls()</code> 可以用于创建一个指定大小的、所有元素都为空的数组，<code>emptyArray()</code>可以创建一个长度为 0 的空数组。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> int_array <span class="token operator">:</span> Array<span class="token operator">&lt;</span>Int<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">//创建一个长度为3的，类型为整型的，数组内元素分别为1,2,3的数组</span>
<span class="token keyword">var</span> int_array_null <span class="token operator">:</span> arrayOfNulls<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment">//创建一个长度为10的，类型为整型的，数组内元素全为null的数组</span>
<span class="token keyword">var</span> string_array <span class="token operator">=</span> emptyArray<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//创建长度为0的空数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是：</p>
<p><code>arrayOf()</code>无须指定数组的长度，但需要依次列出每个数组元素。</p>
<p><code>arrayOfNulls()</code>需要指定数组的长度，数组元素全部被初始化为 null，需要指定数组元素的类型。</p>
<p><code>emptyArray()</code>需要指定数组元素的类型</p>
<p><code>Array</code>的使用方法会在后续的文章中进行介绍，这里就稍稍略过。</p>
<p>值得一提的是，在初始化数组类型的变量时，也是可以对数据的类型进行省略的。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> int_array <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当然，<strong>非字符串数组</strong>也可以采用这种方法来进行初始化，具体的选择就看个人喜好了。</p>
<pre class="line-numbers language-kotlin" data-language="kotlin"><code class="language-kotlin"><span class="token keyword">var</span> int_array <span class="token operator">:</span> IntArray <span class="token operator">=</span> <span class="token function">intArrayOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
</search>
